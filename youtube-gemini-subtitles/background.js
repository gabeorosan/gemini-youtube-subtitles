// Background script for the Chrome extension
chrome.runtime.onInstalled.addListener(() => {
  console.log('YouTube Gemini Subtitles extension installed');
});

// Handle extension icon click
chrome.action.onClicked.addListener((tab) => {
  // Open popup (this is handled automatically by manifest.json)
});

// Listen for messages from content script or popup
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  if (request.action === 'getTabInfo') {
    chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
      if (tabs[0]) {
        sendResponse({
          url: tabs[0].url,
          title: tabs[0].title
        });
      }
    });
    return true; // Keep message channel open for async response
  }
  
  if (request.action === 'transcribeWithGemini') {
    transcribeWithGemini(request.data, request.apiKey, request.targetLanguage, request.selectedModel, request.videoTitle)
      .then(result => {
        sendResponse({ success: true, data: result });
      })
      .catch(error => {
        sendResponse({ success: false, error: error.message });
      });
    return true; // Keep message channel open for async response
  }
});

// Function to handle Gemini API calls from background script
async function transcribeWithGemini(audioData, apiKey, targetLanguage, selectedModel, videoTitle) {
  console.log('Background: Starting transcription with Gemini');
  console.log('Background: Video data:', { title: videoTitle, duration: audioData.duration, model: selectedModel });
  
  try {
    // Validate inputs
    if (!apiKey || !apiKey.trim()) {
      throw new Error('API key is required');
    }
    
    if (!selectedModel || !selectedModel.trim()) {
      throw new Error('Model selection is required');
    }
    
    // Since we can't actually process audio in a browser extension easily,
    // we'll use the video title and description to generate contextual subtitles
    const videoDescription = audioData.description || '';
    const videoLength = Math.floor(audioData.duration) || 60; // Default to 60 seconds if duration is invalid
    
    console.log('Background: Preparing prompt for video:', videoTitle);
    
    const prompt = `Generate realistic subtitles for a YouTube video with the following details:
Title: "${videoTitle}"
Description: "${videoDescription}"
Duration: ${videoLength} seconds
Target Language: ${targetLanguage}

Please create subtitles in SRT format with appropriate timing. Make the subtitles engaging and natural, as if they were actual spoken content for this video topic. The subtitles should be in ${targetLanguage} language. Include approximately ${Math.max(10, Math.floor(videoLength / 6))} subtitle segments with realistic timing.

Format each subtitle as:
[sequence number]
[start time] --> [end time]
[subtitle text in ${targetLanguage}]

Example format:
1
00:00:00,000 --> 00:00:03,000
Welcome to this amazing video!

2
00:00:03,000 --> 00:00:06,000
Today we'll be exploring...

Important: Generate all subtitle text in ${targetLanguage} language.`;

    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${selectedModel}:generateContent?key=${apiKey}`;
    console.log('Background: Making API request to:', apiUrl.replace(apiKey, '[API_KEY_HIDDEN]'));

    const requestBody = {
      contents: [{
        parts: [{
          text: prompt
        }]
      }],
      generationConfig: {
        temperature: 0.7,
        topK: 40,
        topP: 0.95,
        maxOutputTokens: 2048,
      }
    };

    const response = await fetch(apiUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(requestBody)
    });

    console.log('Background: API response status:', response.status);

    if (!response.ok) {
      const errorText = await response.text();
      console.error('Background: Gemini API Error Response:', errorText);
      
      // Parse error for better user feedback
      try {
        const errorData = JSON.parse(errorText);
        const errorMessage = errorData.error?.message || errorText;
        throw new Error(`API Error (${response.status}): ${errorMessage}`);
      } catch (parseError) {
        throw new Error(`API Error (${response.status}): ${errorText}`);
      }
    }

    const data = await response.json();
    console.log('Background: Gemini API Response received, candidates:', data.candidates?.length || 0);
    
    const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text;
    
    if (!generatedText) {
      console.error('Background: No generated text in response:', data);
      throw new Error('No content generated by Gemini API. Please try again.');
    }

    console.log('Background: Generated text length:', generatedText.length);

    // Parse the SRT format
    const subtitles = parseSRTFormat(generatedText);
    console.log('Background: Parsed subtitles count:', subtitles.length);
    
    if (subtitles.length === 0) {
      throw new Error('Failed to parse generated subtitles. Please try again.');
    }
    
    return subtitles;

  } catch (error) {
    console.error('Background: Transcription error:', error);
    
    // Provide more specific error messages
    if (error.message.includes('fetch')) {
      throw new Error('Network error: Unable to connect to Gemini API. Please check your internet connection.');
    } else if (error.message.includes('API_KEY_INVALID')) {
      throw new Error('Invalid API key. Please check your Gemini API key in the extension settings.');
    } else if (error.message.includes('QUOTA_EXCEEDED')) {
      throw new Error('API quota exceeded. Please check your Gemini API usage limits.');
    } else {
      throw new Error('Transcription failed: ' + error.message);
    }
  }
}

// Function to parse SRT format
function parseSRTFormat(srtText) {
  const subtitles = [];
  const blocks = srtText.split(/\n\s*\n/).filter(block => block.trim());
  
  blocks.forEach(block => {
    const lines = block.trim().split('\n');
    if (lines.length >= 3) {
      const sequence = parseInt(lines[0]);
      const timeLine = lines[1];
      const text = lines.slice(2).join('\n');
      
      const timeMatch = timeLine.match(/(\d{2}:\d{2}:\d{2},\d{3})\s*-->\s*(\d{2}:\d{2}:\d{2},\d{3})/);
      if (timeMatch) {
        subtitles.push({
          sequence,
          startTime: timeMatch[1],
          endTime: timeMatch[2],
          text: text.trim()
        });
      }
    }
  });
  
  return subtitles;
}

// Handle storage changes
chrome.storage.onChanged.addListener((changes, namespace) => {
  console.log('Storage changed:', changes);
});